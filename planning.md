

oajygduaegjdged\

1. use recurssion to solve this issue. Im honestly way to fucking lazy to google an optimal olgorithm


function
{
    let Min-num = 0
    let current num = 0
    lsit of every node
    for every node {
        remove a node

    check if it the set is domination --->
        yes: 
         dominationNum
           if Min-num < dominationNum:
                biggestNum = dominationNum;
                print(biggestNum)

        
            function()

        no: return false 

    }
    

}
BIT MASK
so there is going to be a bistmask for the nodes.

0 = no node
1 = node there
lets say n= 2, and the search is tsrating, it will look like 1111
then we also have another fucking bitmsk or an aray, or fucking something, were each nodes neighbour is saved
eahc node will be indentified by an index, so (1)111 will be node number 3
So the array [[], [], [3, 2], [2, 3]] --> example, idk if this is accurate


then, we start by turning bits off 
and check if the set is dominating by using the neighbourhood array
and boom kaboom 


