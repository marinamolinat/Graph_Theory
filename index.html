<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Dominating sets in pawn graphs</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§ </text></svg>">

  </head>
  <body>
    <h1>Dominating sets in pawn graphs</h1>
    <h3>By Marina M for math EE</h3>

    <div id="container" style="width: 800px; height: 600px; background: white; border-width: 5px; border-style: solid; border-radius: 10px;"></div>
    <p>8x8 board</p>
    <script>

        const graph = new graphology.Graph({type: 'directed'});

        // make the size of a board
        let n = 4;
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                 graph.addNode(`(${j}, ${i})`, { x: j, y: i, size: 10, color: "red", label: `(${j}, ${i})` });

            }
          
        }

        const movement = [
            [-1, 1], //diagonally  left
            [1, 1], // diagonally right
            
        ];

        graph.forEachNode((node, attributes) => {
            

            // Example: use attributes.x and attributes.y for movement
            for (let [dx, dy] of movement) {
                let newX = attributes.x + dx;
                let newY = attributes.y + dy;

                // Build ID of potential destination node
                let toId = `(${newX}, ${newY})`;

                if (graph.hasNode(toId)) {
                graph.addDirectedEdge(node, toId, {type: 'arrow', size: 4});
               
                } 
            }

        });

        

        function isSetDominating(graph, nodes) {
            const visited = new Set();
            for (const node of nodes) {
                //mark node as visited, if it hasnt been already marked

                if (!visited.has(node)){
                    visited.add(node);
                }


            
            
                graph.forEachOutboundNeighbor(node, (neighbor) => {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                        }
                
                    });


            }
            return visited.size === graph.order;
        }


function dominationNumber(graph) {
    const nodes = graph.nodes();
    let minSet = null;

    // generats all subsets of nodes
    function* subsets(arr, k = 0, curr = []) {
        if (k === arr.length) {
            yield curr;
            return;
        }
        yield* subsets(arr, k + 1, curr);
        yield* subsets(arr, k + 1, curr.concat([arr[k]]));
    }

    let minSize = nodes.length + 1;
    for (const subset of subsets(nodes)) {
        if (subset.length === 0) continue;
        if (subset.length >= minSize) continue;
        if (isSetDominating(graph, subset)) {
            minSize = subset.length;
            minSet = subset;
        }
    }
    return { number: minSize, set: minSet };
}

// Example usage:
const result = dominationNumber(graph);
console.log("Domination number:", result.number, "Set:", result.set);



       


      
       
       


    


      // Instantiate sigma.js and render the graph
      const sigmaInstance = new Sigma(graph, document.getElementById("container"));
    </script>
  </body>
</html>